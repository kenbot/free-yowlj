package kenbot.yowfree

import scala.annotation.tailrec
import Trampolines._

object ListAppendNaughtyRecursion extends ListAppendProgram {
  
  /**
   * Overflows the stack for large lists, because the algorithm is not tail-recursive.
   * Try running it with "sbt run" -- KABLAMMO!
   */
  def listAppend[A](list1: List[A], list2: List[A]): List[A] = list1 match {
    case Nil => list2
    case head :: tail => head :: listAppend(tail, list2)
  }
  
  def runSolution[A](list1: List[A], list2: List[A]): List[A] = listAppend(list1, list2)
}


object Trampolines {
  
  /**
   * A Trampoline[A], which lets us recurse on the heap rather than the stack, is just
   * the Free Monad generated by the Function0 functor.
   */
  type Trampoline[+A] = Free[Function0, A]

  /**
   * Exercise 2a. 
   * 
   * Write an interpreter for trampolines. 
   * 
   * Hint: Remember that Trampoline[A] is Free[Function0, A] -- there are only 2 things we can do 
   * with a Free -- flatMap, because it is a monad, and pattern matching, which can destructure it
   * into Suspend or Return.
   */
  //@tailrec
  final def runTrampoline[A](trampoline: Trampoline[A]): A = ???
}


object ListAppendRighteousTrampoline extends ListAppendProgram {
  
  /**
   * Exercise 2b.
   * 
   * Implement the same algorithm, this time using a trampoline instead.  
   * This should get the same result, but not blow the stack.
   * 
   * Hint:
   * This is a simple mechanical translation of the original algorithm. 
   * Consider: the algorithm has 2 cases, one to recurse, and one to terminate and return.
   * A Free also has 2 cases: Suspend which recurses, and Return which terminates and returns.
   * 
   */
  def listAppend[A](list1: List[A], list2: List[A]): Trampoline[List[A]] = ???

  def runSolution[A](list1: List[A], list2: List[A]): List[A] = runTrampoline(listAppend(list1, list2))
}



trait ListAppendProgram {
  
  def runSolution[A](list1: List[A], list2: List[A]): List[A]
  
  val list1 = (1 to 9999).toList
  val list2 = (10000 to 20000).toList
  
  def main(args: Array[String]): Unit = {
    println("Starting")
    val result = runSolution(list1, list2)
    println(s"Appended paths: ${result.take(5).mkString(", ")}... and many more")
  }

}


